/*
位运算
& 按位与
| 按位或
^ 按位异或
~ 取反
*/

/*
& 按位与
规律: 一假则假 (1真 0假) [任何数&1, 结果就是那个数]
9 & 5 = ?
1001
&0101
------
0001  == 1
*/

/*
| 按位或
规律: 一真则真 (1真 0假) [任何数&0, 结果都是0]
9 | 5 = ?
1001
&0101
------
1101  == 13
*/

/*
^ 按位异或
规律:
1.相同为0, 不同为1 [异或的结果和参与运算的顺序没有关系]
2.相同的两个数异或为0 (5 ^ 5 = 0)
3.任何数异或0, 结果不变 (9 ^ 0 = 9)
4.任何数异或同一个数两次, 结果不变 (9 ^ 5 ^ 5 = 9 ^ 0 = 9)
9 ^ 5 = ?
1001
&0101
------
1100  == 12
*/

/*
~ 取反
~9 = ?
0000 0000 0000 0000 0000 0000 0000 1001
~
1111 1111 1111 1111 1111 1111 1111 0110 (补码)
-0000 0000 0000 0000 0000 0000 0000 0001
------------------------------------------
1111 1111 1111 1111 1111 1111 1111 0101 (反码)
1000 0000 0000 0000 0000 0000 0000 1010 (原码)  == -10
*/

//    左移&右移: 如果想让某个数乘以2的n次幂, 或者除以2的n次幂, 最高效的方式就是位运算

/*
左移 x << n
规律: x * 2^n

9 << 1
0000 0000 0000 0000 0000 0000 0000 1001
(0)000 0000 0000 0000 0000 0000 0000 10010  --> 18

注意: 被移动的数的最高位会被移除, 所以左移可能会改变数字的正负性
*/
printf("%i\n", 9 << 1);

/*
右移 x >> n
规律: x / 2^n (int, 保留整数)

9 << 1
0000 0000 0000 0000 0000 0000 0000 1001
0000 0000 0000 0000 0000 0000 0000 10[01]
0000 0000 0000 0000 0000 0000 0000 0010   = 4
*/
printf("%i\n", 9 >> 1);